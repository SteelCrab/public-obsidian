# EKS FastAPI 배포

#eks #kubernetes #fastapi #nginx #argocd #docker #aws #LoadBalancer #kustomize

---

```table-of-contents
```

---

## 1. eksctl 클러스터 설정 (cluster.yaml)

### 설정값 테이블

| 플레이스홀더               | 타입  | 값                          | 설명                   | 예시                      |
| -------------------- | --- | -------------------------- | -------------------- | ----------------------- |
| `<CLUSTER_NAME>`     | 이름  | `csjin-cluster`            | EKS 클러스터 이름 (태그와 일치) | `my-cluster`            |
| `<REGION>`           | 이름  | `ap-northeast-1`           | AWS 리전 (도쿄)          | `ap-northeast-2`        |
| `<K8S_VERSION>`      | 버전  | `1.31`                     | 쿠버네티스 버전 (1.29~1.35) | `1.31`                  |
| `<VPC_ID>`           | ID  | `vpc-089fe9578dcc1c00c`    | 기존 VPC ID            | `vpc-0123456789abcdef`  |
| `<PUBLIC_SUBNET_A>`  | ID  | `subnet-0b1805c1e9f180871` | 퍼블릭 서브넷 A (1a)       | `subnet-0123456789abcd` |
| `<PUBLIC_SUBNET_C>`  | ID  | `subnet-0bb8d9b6a060a7b6b` | 퍼블릭 서브넷 C (1c)       | `subnet-0123456789abcd` |
| `<PUBLIC_SUBNET_D>`  | ID  | `subnet-0bc9e9327311ce319` | 퍼블릭 서브넷 D (1d)       | `subnet-0123456789abcd` |
| `<PRIVATE_SUBNET_A>` | ID  | `subnet-03d99036d72d4e535` | 프라이빗 서브넷 A (1a)      | `subnet-0123456789abcd` |
| `<PRIVATE_SUBNET_C>` | ID  | `subnet-0e961c601df663df9` | 프라이빗 서브넷 C (1c)      | `subnet-0123456789abcd` |
| `<PRIVATE_SUBNET_D>` | ID  | `subnet-0d9812b3f0d502b24` | 프라이빗 서브넷 D (1d)      | `subnet-0123456789abcd` |
| `<NODE_GROUP_NAME>`  | 이름  | `csjin-cluster-ng`         | 노드 그룹 이름             | `my-cluster-ng`         |
| `<INSTANCE_TYPE>`    | 이름  | `t3.medium`                | EC2 인스턴스 타입          | `t3.medium`             |
| `<MIN_SIZE>`         | 숫자  | `1`                        | 최소 노드 수              | `1`                     |
| `<MAX_SIZE>`         | 숫자  | `3`                        | 최대 노드 수              | `5`                     |
| `<DESIRED_CAPACITY>` | 숫자  | `2`                        | 초기 노드 개수             | `3`                     |
| `<VOLUME_SIZE>`      | 숫자  | `20`                       | EBS 볼륨 크기 (GB)       | `20`                    |
| `<NODE_SG_ID>`       | ID  | `sg-0746271ec52f43ed1`     | 노드 보안 그룹 (워커 노드용)    | `sg-0123456789abcdef`   |
| `<LB_SG_ID>`         | ID  | `sg-04264d83ba971cc87`     | LB 보안 그룹 (NLB용)      | `sg-0123456789abcdef`   |

### eksctl 설정 파일 (cluster.yaml) with placeholder

```yaml
apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: <CLUSTER_NAME>
  region: <REGION>
  version: "<K8S_VERSION>"

vpc:
  id: "<VPC_ID>"
  subnets:
    public:
      <REGION>a: { id: "<PUBLIC_SUBNET_A>" }
      <REGION>c: { id: "<PUBLIC_SUBNET_C>" }
      <REGION>d: { id: "<PUBLIC_SUBNET_D>" }
    private:
      <REGION>a: { id: "<PRIVATE_SUBNET_A>" }
      <REGION>c: { id: "<PRIVATE_SUBNET_C>" }
      <REGION>d: { id: "<PRIVATE_SUBNET_D>" }
  clusterEndpoints:
    publicAccess: true
    privateAccess: true

managedNodeGroups:
  - name: <NODE_GROUP_NAME>
    instanceType: <INSTANCE_TYPE>
    minSize: <MIN_SIZE>
    maxSize: <MAX_SIZE>
    desiredCapacity: <DESIRED_CAPACITY>
    volumeSize: <VOLUME_SIZE>
    privateNetworking: true
    securityGroups:
      attachIDs:
        - <NODE_SG_ID>       # 노드 보안 그룹
        - <LB_SG_ID>         # LB 보안 그룹 (NLB instance 타입용)
    iam:
      withAddonPolicies:
        imageBuilder: true    # ECR 이미지 접근 권한
        autoScaler: true      # Cluster Autoscaler 권한
        albIngress: true      # 로드밸런서 권한
        cloudWatch: true      # CloudWatch 로그 권한
        ebs: true             # EBS 볼륨 사용 권한
        certManager: true     # SSL/TLS 인증서 자동 발급 권한
        externalDNS: true     # 도메인(Route53) 자동 연결 권한

iam:
  withOIDC: true
```

> [!Note]
> `securityGroups.attachIDs`에 NODE_SG와 LB_SG를 **모두 지정**한다.
> NLB instance 타입은 NLB 자체에 SG가 없으므로 **노드에 LB_SG를 직접 부착**하여 트래픽을 허용한다.

### 관련 명령어

| 명령어 | 설명 |
|--------|------|
| `eksctl create cluster -f cluster.yaml` | 설정 파일로 클러스터 생성 |
| `eksctl delete cluster -f cluster.yaml` | 클러스터 삭제 |
| `eksctl get cluster --region <region>` | 클러스터 목록 조회 |
| `aws eks update-kubeconfig --region <REGION> --name <CLUSTER_NAME>` | kubeconfig 설정 (클러스터 연결) |
| `kubectl get nodes` | 노드 상태 확인 |
| `kubectl cluster-info` | 클러스터 정보 확인 |

---

## 2. 프로젝트 개요

> [!Note]
> [cicd-test](https://github.com/SteelCrab/cicd-test) 레포의 `ci/eks-fastapi` 브랜치에서 구현.
> Nginx 프론트엔드 + FastAPI 백엔드를 EKS에 배포한다.
> Nginx가 NLB로 외부 노출되고, FastAPI는 ClusterIP로 내부 통신만 한다.
> Kustomize base/overlay 패턴 + ArgoCD GitOps로 관리한다.

### 프로젝트 아키텍처

```
사용자 → NLB (internet-facing) :80
          │
          ▼
   ┌──────────────────┐
   │  Nginx Pod       │  LoadBalancer Service (NLB)
   │  (nginx:alpine)  │  port 80 → targetPort 80
   │  :80             │
   └────────┬─────────┘
            │ /api, /health → proxy_pass
            ▼
   ┌──────────────────┐
   │  FastAPI Pod     │  ClusterIP Service
   │  (python:alpine) │  port 8000 → targetPort 8000
   │  :8000           │
   └──────────────────┘
```

### 디렉토리 구조

```
eks/fastapi/
├── argocd/                            # ArgoCD 설정
│   ├── application.yaml               # ArgoCD Application (2개: fastapi-app, nginx-web)
│   └── install.sh                     # ArgoCD 클러스터 설치 스크립트
├── cluster/                           # 클러스터 인프라
│   ├── eks-cluster-init.yaml          # eksctl 클러스터 생성 설정
│   └── install-lbc.sh                 # AWS LB Controller 설치 스크립트
├── kubernetes/                        # Kustomize base
│   ├── fastapi-app/
│   │   ├── deployment.yaml            # 2 replicas, liveness/readiness probe
│   │   ├── service.yaml               # ClusterIP, port 8000
│   │   └── kustomization.yaml
│   └── nginx-web/
│       ├── deployment.yaml            # 2 replicas
│       ├── service.yaml               # LoadBalancer (NLB), port 80
│       └── kustomization.yaml
├── overlays/                          # Kustomize overlay
│   └── production/
│       ├── fastapi-app/
│       │   └── kustomization.yaml     # 이미지 태그 오버라이드
│       ├── nginx-web/
│       │   └── kustomization.yaml     # 이미지 태그 오버라이드
│       └── kustomization.yaml         # production 환경 정의
└── projects/                          # 앱 소스 코드
    ├── fastapi/
    │   ├── Dockerfile                 # python:3.14-alpine 기반
    │   ├── main.py                    # FastAPI 앱 (/, /api, /health)
    │   ├── test_main.py               # 테스트 3개
    │   └── requirements.txt
    └── nginx/
        ├── Dockerfile                 # nginx:alpine 기반
        ├── nginx.conf                 # Nginx 메인 설정
        ├── default.conf               # 리버스 프록시 설정
        └── html/
            ├── index.html             # 프론트엔드 페이지
            ├── style.css
            └── script.js
```

### 엔드포인트

| 경로 | 서비스 | 응답 | 설명 |
|------|--------|------|------|
| `GET /` | Nginx | HTML 페이지 | 정적 웹 페이지 (Nginx 직접 서빙) |
| `GET /api` | Nginx → FastAPI | `{"message": "Hello from EKS FastAPI"}` | JSON API (프록시) |
| `GET /health` | Nginx → FastAPI | `{"status": "healthy"}` | 헬스체크 (프록시) |

---

## 3. FastAPI 백엔드

### Dockerfile

```dockerfile
FROM python:3.14-alpine

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 테스트

```python
def test_read_root():       # GET / → 200, "EKS FastAPI" in response
def test_api_root():         # GET /api → 200, {"message": "Hello from EKS FastAPI"}
def test_health():           # GET /health → 200, {"status": "healthy"}
```

```bash
# 로컬 테스트
cd eks/fastapi/projects/fastapi
pip install -r requirements.txt
pytest test_main.py -v

# Docker 테스트
docker build -t fastapi-eks eks/fastapi/projects/fastapi/
docker run -p 8000:8000 fastapi-eks
curl http://localhost:8000/health
```

---

## 4. Nginx 프론트엔드

### Dockerfile

```dockerfile
FROM nginx:alpine

COPY nginx.conf /etc/nginx/nginx.conf
COPY default.conf /etc/nginx/conf.d/default.conf

WORKDIR /usr/share/nginx/html
RUN rm -rf ./*
COPY --chown=nginx:nginx html/ .

ENV LANG=C.UTF-8
ENV LC_ALL=C.UTF-8

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 리버스 프록시 설정 (default.conf)

```nginx
server {
    listen       80;
    server_name  localhost;
    charset utf-8;

    location / {
        root   /usr/share/nginx/html;
        index  index.html;
    }

    # FastAPI 백엔드 프록시
    location /api {
        proxy_pass http://fastapi-app:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /health {
        proxy_pass http://fastapi-app:8000;
        proxy_set_header Host $host;
    }
}
```

> [!Important]
> `proxy_pass http://fastapi-app:8000` — K8s Service DNS로 FastAPI Pod에 접근한다.
> `fastapi-app`은 FastAPI의 ClusterIP Service 이름이다.

### Docker 테스트

```bash
docker build -t nginx-web eks/fastapi/projects/nginx/
docker run -p 80:80 nginx-web
curl http://localhost/
```

---

## 5. K8s 매니페스트

### FastAPI Deployment 
(`kubernetes/fastapi-app/deployment.yaml`)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fastapi-app
  labels:
    app: fastapi-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: fastapi-app
  template:
    metadata:
      labels:
        app: fastapi-app
    spec:
      containers:
        - name: fastapi
          image: <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/fastapi-app:latest
          ports:
            - containerPort: 8000
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 20
```

### FastAPI Service — ClusterIP 
(`kubernetes/fastapi-app/service.yaml`)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: fastapi-app
  labels:
    app: fastapi-app
spec:
  type: ClusterIP
  selector:
    app: fastapi-app
  ports:
    - port: 8000
      targetPort: 8000
      protocol: TCP
```

> [!Important]
> - **ClusterIP**: 클러스터 내부에서만 접근 가능 (외부 노출 X)
> - 서비스 이름 `fastapi-app`이 Nginx의 `proxy_pass` 호스트명이 된다
> - Nginx Pod에서 `http://fastapi-app:8000`으로 접근

### Nginx Deployment 
(`kubernetes/nginx-web/deployment.yaml`)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-web
  labels:
    app: nginx-web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-web
  template:
    metadata:
      labels:
        app: nginx-web
    spec:
      containers:
        - name: nginx
          image: <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/nginx-web:latest
          ports:
            - containerPort: 80
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
```

### Nginx Service — LoadBalancer
(`kubernetes/nginx-web/service.yaml`)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: pista-svc-nginx-web
  labels:
    app: nginx-web
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "external"
    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "instance"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    service.beta.kubernetes.io/aws-load-balancer-security-groups: "<LB_SG_ID>"
spec:
  type: LoadBalancer
  selector:
    app: nginx-web
  ports:
    - name: http
      port: 80
      targetPort: 80
      protocol: TCP
```

> [!Important]
> - NLB가 외부 트래픽을 Nginx Pod으로 전달한다
> - `nlb-target-type: instance` → NLB가 노드의 NodePort를 경유
> - `<LB_SG_ID>`를 annotation에 지정 + cluster.yaml attachIDs에도 포함

### Kustomize 설정
> [!Note]
>  - 원본 파일을 그대로 사용하여 필요한 부분만 덮어쓰기  
> 	 (원본은 건드리지 않고, 바꿀 부분만 패치처럼 덧붙이는 도구)
>  - 
#### Base — FastAPI
(`kubernetes/fastapi-app/kustomization.yaml`)

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - deployment.yaml
  - service.yaml
```

#### Base — Nginx
(`kubernetes/nginx-web/kustomization.yaml`)

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - deployment.yaml
  - service.yaml
```

#### Production Overlay — FastAPI
(`overlays/production/fastapi-app/kustomization.yaml`)

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - ../../../kubernetes/fastapi-app
images:
  - name: <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/fastapi-app
    newTag: latest
```

#### Production Overlay — Nginx 
(`overlays/production/nginx-web/kustomization.yaml`)

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - ../../../kubernetes/nginx-web
images:
  - name: <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/nginx-web
    newTag: latest
```

#### Production Root (`overlays/production/kustomization.yaml`)

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - fastapi-app
  - nginx-web
```

---

## 6. ArgoCD 설정

### ArgoCD Application
(`argocd/application.yaml`)

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: fastapi-app
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/<GITHUB_OWNER>/<GITHUB_REPO>.git
    targetRevision: ci/eks-fastapi
    path: eks/fastapi/overlays/production/fastapi-app
  destination:
    server: https://kubernetes.default.svc
    namespace: default
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: nginx-web
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/<GITHUB_OWNER>/<GITHUB_REPO>.git
    targetRevision: ci/eks-fastapi
    path: eks/fastapi/overlays/production/nginx-web
  destination:
    server: https://kubernetes.default.svc
    namespace: default
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
```

> [!Note]
> - **2개 Application으로 분리**: 서비스별 독립 배포/롤백 가능
> - `automated.prune: true` → Git에서 삭제된 리소스 자동 제거
> - `automated.selfHeal: true` → 수동 변경 감지 시 Git 상태로 복구
> - `targetRevision: ci/eks-fastapi` → 감시 대상 브랜치

### ArgoCD 설치 스크립트 (`argocd/install.sh`)

```bash
# 1. ArgoCD 네임스페이스 생성
kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

# 2. ArgoCD 설치
kubectl apply -n argocd --server-side --force-conflicts \
  -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# 3. ArgoCD Pod 준비 대기
kubectl wait --for=condition=ready pod \
  -l app.kubernetes.io/name=argocd-server \
  -n argocd --timeout=120s

# 4. ArgoCD Server를 LoadBalancer로 노출
kubectl patch svc argocd-server -n argocd \
  -p '{"spec": {"type": "LoadBalancer"}}'

# 5. 초기 admin 비밀번호 출력
kubectl -n argocd get secret argocd-initial-admin-secret \
  -o jsonpath="{.data.password}" | base64 -d
```

### ArgoCD 관련 명령어

| 명령어 | 설명 |
|--------|------|
| `./eks/fastapi/argocd/install.sh` | ArgoCD 클러스터 설치 |
| `kubectl apply -f eks/fastapi/argocd/application.yaml` | Application 등록 |
| `kubectl get svc argocd-server -n argocd` | ArgoCD Server 주소 (EXTERNAL-IP) |
| `kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" \| base64 -d` | 초기 비밀번호 확인 |
| `argocd login <SERVER> --username admin --password <PW> --grpc-web --insecure` | CLI 로그인 |
| `argocd account update-password` | 비밀번호 변경 |
| `argocd app get fastapi-app` | Application 상태 확인 |
| `argocd app sync fastapi-app` | 수동 Sync |

---

## 7. GitHub Actions (CI/CD)

### 워크플로우

| 워크플로우 | 트리거 경로 | 설명 |
|----------|-----------|------|
| `fastapi-eks-argocd.yml` | `eks/fastapi/projects/fastapi/**`, `eks/fastapi/kubernetes/fastapi-app/**` | FastAPI 빌드 → ECR → ArgoCD |
| `nginx-web-eks-argocd.yml` | `eks/fastapi/projects/nginx/**`, `eks/fastapi/kubernetes/nginx-web/**` | Nginx 빌드 → ECR → ArgoCD |

### 배포 흐름

```
Push (main / ci/eks-fastapi)
  │
  ├─ build job:
  │     FastAPI: flake8 lint + pytest
  │     Nginx:   docker build (테스트)
  │
  └─ deploy job (production 환경 승인):
        1. AWS credentials 설정
        2. ECR 로그인
        3. Docker build + ECR push (:latest + :$GITHUB_SHA)
        4. ArgoCD CLI 설치
        5. ArgoCD 로그인 (--insecure)
        6. Private 레포 등록 (GH_PAT 설정 시)
        7. argocd app set --kustomize-image (이미지 태그 업데이트)
        8. argocd app sync (배포)
        9. argocd app wait --timeout 300 (완료 대기)
```

### 워크플로우 예시 (FastAPI)

```yaml
deploy:
  runs-on: ubuntu-latest
  needs: build
  if: github.event_name == 'push'
  environment: production
  env:
    GH_PAT: ${{ secrets.GH_PAT }}

  steps:
    # ... (1~3: AWS credentials, ECR login, Docker build & push)

    # 4. ArgoCD CLI 설치
    - name: Install ArgoCD CLI
      run: |
        curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
        chmod +x argocd
        sudo mv argocd /usr/local/bin/

    # 5. ArgoCD 로그인
    - name: ArgoCD Login
      run: |
        argocd login "${{ secrets.ARGOCD_SERVER }}" \
          --username admin \
          --password "${{ secrets.ARGOCD_PASSWORD }}" \
          --grpc-web \
          --insecure

    # 6. Private 레포 등록 (GH_PAT secret 설정 시에만 실행)
    - name: Add private repo to ArgoCD
      if: env.GH_PAT != ''
      run: |
        argocd repo add https://github.com/${{ github.repository }}.git \
          --username "${{ secrets.GH_USERNAME }}" \
          --password "${{ secrets.GH_PAT }}" \
          --upsert

    # 7. ArgoCD 이미지 태그 업데이트 및 Sync
    - name: Deploy via ArgoCD
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: "${{ secrets.ECR_REPOSITORY_FASTAPI_APP }}"
        IMAGE_TAG: ${{ github.sha }}
      run: |
        argocd app set fastapi-app \
          --kustomize-image "fastapi-app=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        argocd app sync fastapi-app

    # 8. 배포 완료 대기
    - name: Wait for deployment
      run: |
        argocd app wait fastapi-app --timeout 300
```

> [!Note]
> - `--kustomize-image "fastapi-app=..."`: 제네릭 이미지 이름 → 실제 ECR 주소로 런타임 오버라이드
> - `--insecure`: ArgoCD 자체 서명 인증서 무시 (NLB EXTERNAL-IP 접속 시 필수)
> - `GH_PAT`: Private 레포인 경우에만 필요. job 레벨 `env`로 선언 후 `if: env.GH_PAT != ''` 사용
> - `--timeout 300`: NLB 최초 프로비저닝에 2~5분 소요될 수 있음
> - `environment: production` → GitHub Environment 승인 게이트 사용

---

## 8. 초기 구축 프로세스

아래 순서대로 진행한다. 모든 단계가 완료되어야 CI/CD가 동작한다.

### 전체 흐름

```
VPC 구축 → 서브넷 태그 → SG 생성 → eksctl 클러스터 생성
  → LB Controller 설치 → ECR 생성 + 초기 이미지 Push
  → ArgoCD 설치 → Application 등록 → GitHub Secrets 등록
  → 이후 Push만으로 자동 배포
```

### Step 1. EKS 클러스터 생성

```bash
eksctl create cluster -f eks/fastapi/cluster/eks-cluster-init.yaml
```

### Step 2. kubeconfig 설정

eksctl이 자동 설정하지만, 다른 환경에서 작업할 경우 수동 연결한다.

```bash
aws eks update-kubeconfig --name <CLUSTER_NAME> --region <REGION>
kubectl get nodes
```

### Step 3. AWS Load Balancer Controller 설치

NLB 생성을 위해 필수다.

```bash
./eks/fastapi/cluster/install-lbc.sh
```

### Step 3-1. LBC IAM 정책 업데이트

`install-lbc.sh`의 IAM 정책 버전이 오래된 경우 최신 API 권한(`DescribeListenerAttributes` 등)이 빠져있을 수 있다. NLB 생성 시 `AccessDenied` 에러 발생 시 아래 명령어로 업데이트한다.

```bash
# 최신 IAM 정책 다운로드
curl -o iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.12.0/docs/install/iam_policy.json

# 기존 정책 업데이트
aws iam create-policy-version \
  --policy-arn arn:aws:iam::<ACCOUNT_ID>:policy/AWSLoadBalancerControllerIAMPolicy \
  --policy-document file://iam_policy.json \
  --set-as-default

rm iam_policy.json

# LBC 재시작
kubectl rollout restart deployment aws-load-balancer-controller -n kube-system
```

### Step 4. ECR 리포지토리 생성

```bash
aws ecr create-repository --repository-name fastapi-app --region <REGION>
aws ecr create-repository --repository-name nginx-web --region <REGION>
```

### Step 5. 초기 Docker 이미지 빌드 및 ECR 푸시

ArgoCD Application 등록 전에 이미지가 ECR에 존재해야 Pod가 정상 기동한다.

```bash
# ECR 로그인
aws ecr get-login-password --region <REGION> | \
  docker login --username AWS --password-stdin <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com

# FastAPI 이미지 빌드 & 푸시
docker build -t <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/fastapi-app:latest \
  ./eks/fastapi/projects/fastapi/
docker push <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/fastapi-app:latest

# Nginx 이미지 빌드 & 푸시
docker build -t <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/nginx-web:latest \
  ./eks/fastapi/projects/nginx/
docker push <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/nginx-web:latest
```

### Step 6. ArgoCD 설치

```bash
./eks/fastapi/argocd/install.sh
```

또는 수동으로:

```bash
kubectl create namespace argocd
kubectl apply -n argocd --server-side --force-conflicts \
  -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
```

### Step 7. ArgoCD Server 주소 및 비밀번호 확인

```bash
# ARGOCD_SERVER 확인 (EXTERNAL-IP 값)
kubectl get svc argocd-server -n argocd

# ARGOCD_PASSWORD 확인
kubectl -n argocd get secret argocd-initial-admin-secret \
  -o jsonpath="{.data.password}" | base64 -d
```

### Step 8. ArgoCD 비밀번호 변경

초기 비밀번호는 보안상 변경을 권장한다.

```bash
argocd login <ARGOCD_SERVER> --username admin --password <초기 비밀번호> --grpc-web --insecure
argocd account update-password
```

### Step 9. GitHub Secrets 등록

```bash
# AWS
gh secret set AWS_ACCESS_KEY_ID
gh secret set AWS_SECRET_ACCESS_KEY
gh secret set AWS_REGION --body "<REGION>"

# ECR (서비스별 리포지토리)
gh secret set ECR_REPOSITORY_FASTAPI_APP --body "fastapi-app"
gh secret set ECR_REPOSITORY_NGINX_WEB --body "nginx-web"

# ArgoCD (Step 7~8에서 확인/변경한 값)
gh secret set ARGOCD_SERVER --body "<Step 7에서 확인한 EXTERNAL-IP>"
gh secret set ARGOCD_PASSWORD --body "<Step 8에서 변경한 비밀번호>"

# Private 레포인 경우 (선택)
gh secret set GH_USERNAME --body "<GitHub 사용자명>"
gh secret set GH_PAT --body "<GitHub Personal Access Token>"
```

### Step 10. GitHub Environment 설정

Deploy job은 `production` Environment의 승인을 거쳐 실행한다.

Settings → Environments → New environment → `production`에서 **Required reviewers** 체크 후 승인자를 추가한다.

### Step 11. ArgoCD Application 등록

fastapi-app, nginx-web 두 개의 Application을 등록한다.

```bash
kubectl apply -f eks/fastapi/argocd/application.yaml
```

> [!Note]
> **왜 2개 Application인가?** 각 서비스의 빌드/배포 주기가 다르기 때문이다.
> - 1개면 FastAPI만 수정해도 Nginx까지 재배포되고, 동시 Push 시 sync 충돌 가능
> - 2개로 분리하면 서비스별 독립 배포/롤백, ArgoCD 대시보드에서 개별 상태 확인 가능

### Step 12. 배포 확인

```bash
# ArgoCD Application 상태 확인
argocd app get fastapi-app
argocd app get nginx-web

# Pod 상태 확인
kubectl get pods

# NLB 주소 확인 (EXTERNAL-IP로 브라우저 접속)
kubectl get svc pista-svc-nginx-web

# 엔드포인트 테스트
curl http://<NLB_DNS>/
curl http://<NLB_DNS>/api
curl http://<NLB_DNS>/health
```

> 여기까지 완료하면 이후 Push만으로 자동 배포된다.

### 수동 배포 (ArgoCD 없이)

```bash
kubectl apply -k eks/fastapi/overlays/production/
# 또는 개별 서비스
kubectl apply -k eks/fastapi/kubernetes/fastapi-app/
kubectl apply -k eks/fastapi/kubernetes/nginx-web/
```

---

## 9. 트래픽 흐름

```
사용자 → NLB (internet-facing) :80
          │
          ▼
   ┌──────────────────────────────────┐
   │  Node (EC2)                      │
   │                                  │
   │   ┌────────────┐  proxy_pass     │
   │   │ Nginx Pod  │ ──────────────┐ │
   │   │ :80        │               │ │
   │   └────────────┘               │ │
   │   ┌────────────┐               │ │
   │   │ Nginx Pod  │ ────────┐    │ │
   │   │ :80        │         │    │ │
   │   └────────────┘         │    │ │
   │                          ▼    ▼ │
   │   ┌────────────┐  ClusterIP     │
   │   │ FastAPI Pod│  :8000         │
   │   └────────────┘               │
   │   ┌────────────┐               │
   │   │ FastAPI Pod│  :8000         │
   │   └────────────┘               │
   └──────────────────────────────────┘
```

### 요청 경로별 흐름

| 경로 | 흐름 |
|------|------|
| `GET /` | 사용자 → NLB :80 → Nginx Pod :80 → 정적 HTML 응답 |
| `GET /api` | 사용자 → NLB :80 → Nginx Pod :80 → `proxy_pass` → FastAPI Pod :8000 → JSON 응답 |
| `GET /health` | 사용자 → NLB :80 → Nginx Pod :80 → `proxy_pass` → FastAPI Pod :8000 → JSON 응답 |

---

## 10. 보안 그룹 설정

### 필요 보안 그룹

| 보안 그룹                  | 용도                  | 생성 방식                                               |
| ---------------------- | ------------------- | --------------------------------------------------- |
| 클러스터 SG                | EKS 컨트롤 플레인 ↔ 노드 통신 | `eksctl create cluster` 자동 생성                       |
| LB SG (`<LB_SG_ID>`)   | NLB 외부 트래픽          | 수동 생성 → Service annotation + cluster.yaml attachIDs |
| 노드 SG (`<NODE_SG_ID>`) | 워커 노드 트래픽 제어        | 수동 생성 → cluster.yaml attachIDs                      |

### eksctl 자동 생성 보안 그룹 (3개)

`eksctl create cluster` 실행 시 다음 3개 SG가 **자동 생성**되어 노드/컨트롤 플레인에 부착된다.

| 이름                               | 역할             | 설명                             |
| -------------------------------- | -------------- | ------------------------------ |
| `eks-cluster-sg-<CLUSTER_NAME>`  | **클러스터 SG**    | 컨트롤 플레인 + 노드 공유. EKS가 자동 생성    |
| `ClusterSharedNodeSecurityGroup` | **노드 공유 SG**   | 노드 간 통신 허용. eksctl이 자동 생성      |
| `ControlPlaneSecurityGroup`      | **컨트롤 플레인 SG** | 컨트롤 플레인 ↔ 노드 통신. eksctl이 자동 생성 |

> [!Important]
> 이 3개는 이미 자동으로 연결되어 있으므로 **`attachIDs`에 넣지 않는다**.
> `attachIDs`에는 **수동 생성한 커스텀 SG**(노드 SG, LB SG)만 추가한다.

```
자동 생성 SG (건드릴 필요 X)           수동 생성 SG (attachIDs에 추가)
──────────────────────────         ──────────────────────────────
클러스터 SG (eks-cluster-sg-*)       노드 SG (<NODE_SG_ID>)
노드 공유 SG (ClusterSharedNode*)    LB SG  (<LB_SG_ID>)
컨트롤 플레인 SG (ControlPlane*)
```

### 보안 그룹 생성 순서

```
1. eksctl create cluster          → 클러스터 SG 자동 생성됨 (3개)
2. 클러스터 SG ID 확인               → aws eks describe-cluster
3. 노드 SG 생성                     → aws ec2 create-security-group
4. 노드 SG에 인바운드 규칙 추가:
   - 소스: 자기 자신 (노드 SG ID)     → 노드 간 통신
   - 소스: 클러스터 SG ID            → 컨트롤 플레인 → 노드
5. LB SG 생성 + 인바운드 80/443 추가
6. cluster.yaml에 두 SG 모두 연결:
   securityGroups:
     attachIDs: ["<NODE_SG_ID>", "<LB_SG_ID>"]
```

### 클러스터 SG 확인 명령어

```bash
# 클러스터 생성 후 자동 생성된 클러스터 SG ID 확인
aws eks describe-cluster --name <CLUSTER_NAME> \
  --query cluster.resourcesVpcConfig.clusterSecurityGroupId \
  --output text
```

> [!Note]
> 클러스터 SG는 직접 만드는 것이 아니라 `eksctl create cluster` 시 **자동 생성**된다.
> 클러스터 SG ID를 확인한 뒤 노드 SG 인바운드 규칙에 소스로 추가한다.

### 노드 SG 자기 참조 설정

```bash
# 1단계: SG 생성 (ID 발급)
aws ec2 create-security-group \
  --group-name eks-node-sg \
  --description "EKS Node SG" \
  --vpc-id <VPC_ID>
# → sg-0746271ec52f43ed1 반환

# 2단계: 자기 자신을 소스로 인바운드 규칙 추가
aws ec2 authorize-security-group-ingress \
  --group-id sg-0746271ec52f43ed1 \
  --protocol all \
  --source-group sg-0746271ec52f43ed1

# 3단계: 클러스터 SG를 소스로 추가
aws ec2 authorize-security-group-ingress \
  --group-id sg-0746271ec52f43ed1 \
  --protocol all \
  --source-group <CLUSTER_SG_ID>
```

### 노드 보안 그룹 규칙

| 방향 | 포트 | 프로토콜 | 소스/대상 | 설명 |
|------|------|----------|----------|------|
| Inbound | All | All | 노드 SG (자기 자신) | 노드 간 통신 (Pod ↔ Pod) |
| Inbound | All | All | 클러스터 SG | 컨트롤 플레인 → 노드 |
| Inbound | 30000-32767 | TCP | `0.0.0.0/0` | NLB → NodePort (instance 타입) |
| Outbound | All | All | `0.0.0.0/0` | ECR Pull 등 |

### LB 보안 그룹 규칙

| 방향 | 포트 | 프로토콜 | 소스/대상 | 설명 |
|------|------|----------|----------|------|
| Inbound | 80 | TCP | `0.0.0.0/0` | HTTP 트래픽 |
| Inbound | 443 | TCP | `0.0.0.0/0` | HTTPS 트래픽 |
| Outbound | All | All | `0.0.0.0/0` | 노드로 전달 |

### NLB 트래픽 흐름 (instance 타입)

```
Client (IP: 1.2.3.4)
  → NLB (port 80, LB SG 평가)
  → Node (NodePort 30000-32767, 노드 SG 평가, 소스 IP = 1.2.3.4)
  → Pod (targetPort 80)
```

> [!Important]
> NLB instance 타입은 L4(TCP)에서 **클라이언트 IP를 보존**한다.
> 따라서 NodePort 인바운드를 `--source-group`(LB SG)이 아닌 **`0.0.0.0/0`으로 열어야** 한다.
> `--source-group`을 사용하면 소스 IP가 LB SG와 매칭되지 않아 트래픽이 차단된다.
>
> `cluster.yaml`의 `attachIDs`에 NODE_SG와 LB_SG를 모두 포함하는 이유다.
> Service annotation의 `aws-load-balancer-security-groups`는 NLB 태그용이다.

---

## 11. GitHub Secrets

### 필수 시크릿 (7개)

| 시크릿 | 설명 | 확인 방법 |
|--------|------|----------|
| `AWS_ACCESS_KEY_ID` | IAM 액세스 키 | AWS IAM 콘솔 |
| `AWS_SECRET_ACCESS_KEY` | IAM 시크릿 키 | AWS IAM 콘솔 |
| `AWS_REGION` | AWS 리전 | `ap-southeast-1` 등 |
| `ECR_REPOSITORY_FASTAPI_APP` | FastAPI ECR 레포 이름 | `fastapi-app` |
| `ECR_REPOSITORY_NGINX_WEB` | Nginx ECR 레포 이름 | `nginx-web` |
| `ARGOCD_SERVER` | ArgoCD Server 주소 | Step 7: `kubectl get svc argocd-server -n argocd` (EXTERNAL-IP) |
| `ARGOCD_PASSWORD` | ArgoCD admin 비밀번호 | Step 8: `argocd account update-password`로 변경한 값 |

### 선택 시크릿 (Private 레포)

| 시크릿           | 설명                                          |
| ------------- | ------------------------------------------- |
| `GH_USERNAME` | GitHub 사용자명                                 |
| `GH_PAT`      | GitHub Personal Access Token (repo read 권한) |

> [!Note]
> - ArgoCD 방식은 `EKS_CLUSTER_NAME`, `K8S_NAMESPACE`가 **불필요**하다
> - ArgoCD가 클러스터 내부에서 직접 배포하므로 kubeconfig 연결이 필요 없다
> - `GH_PAT` 설정 시 워크플로우에서 자동으로 ArgoCD에 Private 레포 등록
> - 상세: [[cicd-deploy-eks]]

---

## 12. 전체 플레이스홀더

| 플레이스홀더 | 설명 | 위치 |
|-------------|------|------|
| `<ACCOUNT_ID>` | AWS 계정 ID | `kubernetes/*/deployment.yaml`, `overlays/` |
| `<REGION>` | AWS 리전 | `kubernetes/*/deployment.yaml`, `cluster.yaml` |
| `<LB_SG_ID>` | LB 보안 그룹 ID | `kubernetes/nginx-web/service.yaml` (annotation) |
| `<NODE_SG_ID>` | 노드 보안 그룹 ID | `cluster.yaml` |
| `<CLUSTER_SG_ID>` | 클러스터 보안 그룹 ID (자동 생성) | 노드 SG 인바운드 규칙 소스 |
| `<CLUSTER_NAME>` | EKS 클러스터 이름 | `cluster.yaml` |
| `<VPC_ID>` | VPC ID | `cluster.yaml` |
| `<PUBLIC_SUBNET_*>` | 퍼블릭 서브넷 (3개) | `cluster.yaml` |
| `<PRIVATE_SUBNET_*>` | 프라이빗 서브넷 (3개) | `cluster.yaml` |
| `<GITHUB_OWNER>` | GitHub 사용자/조직 | `argocd/application.yaml` |
| `<GITHUB_REPO>` | GitHub 레포 이름 | `argocd/application.yaml` |

> [!Tip]
> - VSCode `Cmd+Shift+H`로 `eks/fastapi/**/*.yaml` 경로 내 플레이스홀더를 일괄 교체할 수 있다
> - CI 워크플로우는 `--kustomize-image`로 런타임에 ECR 주소를 주입하므로 매니페스트 플레이스홀더 교체 없이 배포 가능하다
> - K8s 매니페스트에는 제네릭 이미지 이름(`fastapi-app:latest`)을 사용하고, Git 히스토리에 AWS 계정 ID 노출을 방지한다

---

## 13. 트러블슈팅

### 1. ArgoCD Login TLS 인증서 에러

```
x509: certificate is valid for localhost, argocd-server... not <EXTERNAL-IP>
```

**원인:** ArgoCD Server의 자체 서명 인증서가 NLB EXTERNAL-IP와 일치하지 않음.

**해결:** `argocd login`에 `--insecure` 플래그 추가.

```bash
argocd login <ARGOCD_SERVER> --username admin --password <PASSWORD> --grpc-web --insecure
```

### 2. Git 히스토리에 AWS 계정 ID 노출

**원인:** deployment.yaml, kustomization.yaml에 ECR 주소(`<ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/...`)가 하드코딩됨.

**해결:**
1. K8s 매니페스트에는 제네릭 이미지 이름(`fastapi-app:latest`)을 사용
2. CI에서 `--kustomize-image`로 런타임에 실제 ECR 주소를 주입
3. 과거 히스토리는 `git filter-repo`로 정리

```bash
# 제네릭 이름 → CI에서 런타임 오버라이드
# Git:     image: fastapi-app:latest
# ArgoCD:  --kustomize-image "fastapi-app=<ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/fastapi-app:<SHA>"

# 과거 히스토리 정리
brew install git-filter-repo
git filter-repo --replace-text <(echo '<ACCOUNT_ID>==>__ACCOUNT_ID__') --force
git remote add origin <REPO_URL>
git push origin --all --force
```

### 3. ArgoCD Private 레포 접근 실패

```
authentication required: Repository not found
```

**원인:** 레포를 Private으로 전환했으나 ArgoCD에 접근 credential이 없음.

**해결:** CI 워크플로우에 조건부 레포 등록 단계 추가. `GH_PAT` secret 설정 시에만 실행됨.

```yaml
# job 레벨에서 env 선언
env:
  GH_PAT: ${{ secrets.GH_PAT }}

# step에서 조건 체크
- name: Add private repo to ArgoCD
  if: env.GH_PAT != ''
  run: |
    argocd repo add https://github.com/${{ github.repository }}.git \
      --username "${{ secrets.GH_USERNAME }}" \
      --password "${{ secrets.GH_PAT }}" \
      --upsert
```

> [!Note]
> `if: ${{ secrets.GH_PAT != '' }}`는 동작하지 않는다. job 레벨 `env`로 선언 후 `if: env.GH_PAT != ''`를 사용해야 한다.

### 4. NLB Service가 Progressing에서 멈춤 (플레이스홀더)

```
Failed build model due to couldn't find all security groups: requested names [<LB_SG_ID>] but found []
```

**원인:** `nginx-web/service.yaml`의 `aws-load-balancer-security-groups` annotation에 `<LB_SG_ID>` 플레이스홀더가 그대로 남아있음.

**해결:** 실제 LB 보안 그룹 ID로 교체.

```bash
aws ec2 describe-security-groups --filters "Name=vpc-id,Values=<VPC_ID>" \
  --query "SecurityGroups[*].{ID:GroupId,Name:GroupName,Desc:Description}" --output table
```

### 5. NLB Service가 Progressing에서 멈춤 (IAM 권한)

```
AccessDenied: User: arn:aws:sts::<ACCOUNT_ID>:assumed-role/AmazonEKSLoadBalancerControllerRole/...
is not authorized to perform: elasticloadbalancing:DescribeListenerAttributes
```

**원인:** LBC의 IAM 정책이 오래된 버전이라 최신 ELBv2 API 권한이 빠져있음.

**해결:** 최신 IAM 정책으로 업데이트 후 LBC 재시작. (Step 3-1 참고)

```bash
curl -o iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.12.0/docs/install/iam_policy.json
aws iam create-policy-version \
  --policy-arn arn:aws:iam::<ACCOUNT_ID>:policy/AWSLoadBalancerControllerIAMPolicy \
  --policy-document file://iam_policy.json \
  --set-as-default
rm iam_policy.json
kubectl rollout restart deployment aws-load-balancer-controller -n kube-system
```

### 6. NLB 접속 불가 (노드 보안 그룹)

NLB URL로 접속했으나 응답 없음 (타임아웃).

**원인:** NLB instance 타입은 NodePort를 통해 노드에 트래픽을 전달한다. 노드 SG에 NodePort 범위 인바운드가 없으면 트래픽이 차단된다. NLB는 L4(TCP)에서 **클라이언트 IP를 보존**하므로, `--source-group`(LB SG)이 아닌 `0.0.0.0/0`으로 열어야 한다.

**해결:**

```bash
aws ec2 authorize-security-group-ingress \
  --group-id <NODE_SG_ID> \
  --protocol tcp \
  --port 30000-32767 \
  --cidr 0.0.0.0/0
```

> [!Important]
> `--source-group`을 사용하면 NLB가 클라이언트 IP를 보존하기 때문에 소스 IP가 LB SG와 매칭되지 않아 트래픽이 차단된다.

### 7. argocd app wait 타임아웃

```
timed out (120s) waiting for app "***" match desired state
```

**원인:** NLB 프로비저닝에 2~5분 소요되어 Service가 `Progressing` 상태를 유지한다. Deployment는 `Healthy`이지만 Service가 완료되지 않아 전체 앱이 타임아웃된다.

**해결:** timeout을 300초로 증가.

```bash
argocd app wait <APP_NAME> --timeout 300
```

> NLB는 최초 생성 시에만 시간이 걸린다. 이후 배포에서는 Service `unchanged`로 즉시 통과된다.

---

## 관련 노트

- [[CICD_2026-02-06]] - 이전: EKS 클러스터 구축
- [[cicd-deploy-eks]] - EKS 배포 레퍼런스
- [[Kubectl_MOC]] - kubectl 명령어 MOC
- [[k8s-service-loadbalancer]] - LoadBalancer Service
- [[k8s-service-clusterip]] - ClusterIP Service
- [[k8s-service-nodeport]] - NodePort Service
