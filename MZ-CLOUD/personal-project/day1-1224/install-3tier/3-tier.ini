# ######################################################################################################
# ######################################################################################################
# 프로젝트 3-Tier 구성을 위한 VMware 구성
# IP 부여시 참고 사항 : Kubernetes NIC
#  - Flannel(10.244.0.0/16) / Weave Net(10.32.0.0/12) / Calico(192.168.0.0/16) / Cilium(유연)
#  ex) Calico를 사용하고자 할경우 아래 IP와 충돌할 수 있다.
# +====================================================================================================+
# |   VMware      Processors  Memory  Hostname    IP                           extPort     Storage     |
# +----------------------------------------------------------------------------------------------------+
# |   Bestion     1           1024    bestion     10.100.0.3/172.100.100.3     22         30Gi         |
# |   NFS         1           1024    nfs                   /172.100.100.4     22         30Gi/50Gi    |
# |   Mysql       2           4096    mysql                 /172.100.100.5     22         30Gi/50Gi    |
# +----------------------------------------------------------------------------------------------------+
# |   k8s-Master  2           4096    k8s-m                 /172.100.100.6     22         30Gi         |
# |   k8s-Node1   2           4096    k8s-n1                /172.100.100.7     22         30Gi/50Gi    |
# |   k8s-Node2   2           4096    k8s-n2                /172.100.100.8     22         30Gi/50Gi    |
# |   k8s-Node3   2           4096    k8s-n3                /172.100.100.9     22         30Gi/50Gi    |
# +====================================================================================================+

# ######################################################################################################
# processors:2, Memory:4G, Storage:30G+50G, NIC 2ea:(NAT:10.100.0.0/24 / Host-only:172.100.100.0/24) 
# 기본 설치 패키지 : vim net-tools openssh-server ssh tree htop curl open-vm-tools nfs-common : 인스턴스 별로 필요한 패키지만
# ======================================================================================================
# A. 해당 패키지가 설치된 기본 리눅스 설치
# B. Default Ubuntu : 해당 번전 상태에서 마운트되지 않는 상태로
#  a) Default clone --> 50G Storage 추가 --> VM rename --> hostname/ip 설정 --> Bestion Host 구성
#  b) Default clone --> VM rename --> Storage Mount --> hostname/ip 설정 NFS System 구성
#  c) Default clone --> VM rename --> Storage Mount --> hostname/ip 설정 MySQL Master 구성
#  d) Default clone --> VM rename --> Storage Mount --> hostname/ip 설정 k8s-Master(kubeadm init 이전까지)
#  e) k8s-Master clone --> VM rename --> 노드1 --> hostname/ip 설정 --> 노드1 clone --> 노드2,3 --> hostname/ip 설정
# ######################################################################################################




# ######################################################################################################
# Bestion Host 구성
# ======================================================================================================
# 1. SSH 환경 설정
# ------------------------------------------------------------------------------------------------------
sudo vi /etc/ssh/sshd_config
# 1) 루트 로그인 금지 : line 42
PermitRootLogin no
# 2) 패스워드 로그인 금지 (SSH Key 로그인만 허용) : line 66
PasswordAuthentication no
# 3) 빈 패스워드 금지 : line 67
PermitEmptyPasswords no
# 4) 설정 적용
sudo systemctl restart ssh.socket
#
# 1. 기본 방화벽 설정 (모든 인바운드 차단, 아웃바운드 허용)
sudo ufw default deny incoming
sudo ufw default allow outgoing

# 2. 내 PC(관리자)의 공인 IP에서만 베스천 접속 허용 (보안 강화)
# '사용자 공인_IP' 부분을 본인의 실제 외부 IP로 바꾸세요.
# sudo ufw allow from [사용자 공인_IP] to any port 22 proto tcp
sudo ufw allow 22/tcp 
# 3. UFW 활성화
sudo ufw enable
# 4. 확인
sudo ufw status

# ======================================================================================================
# 기타 인스턴스의 인터넷 outgoing을 위한 베스천 설정 : iptables사용 or 
# ------------------------------------------------------------------------------------------------------
# iptables를 이용한 IP Masquerading(NAT) 
# bestion의 /etc/sysctl.conf 환경 변경
# line 28 : net.ipv4.ip_forward=1을 주석 해제
# 변경 사항 적용
sudo sysctl -p

# ens33은 외부(인터넷) 연결용 인터페이스 이름입니다
sudo iptables -t nat -A POSTROUTING -o ens34 -j MASQUERADE

# 포워딩 허용 규칙 (기본값이 DROP일 경우 필요)
sudo iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
sudo iptables -A FORWARD -i ens33 -o ens34 -j ACCEPT

# 기타 인스턴스 (NFS, MySQL, k8s) 설정
# 기타 인스턴스의 네트워크 설정에서 기본 게이트웨이를 Bastion 서버의 내부 IP로 지정한다
---
network:
  version: 2
  ethernets:
    ens33:
      addresses:
      - 172.100.100.4/24
      nameservers:
        addresses:
        - 8.8.8.8
        search:
        - 8.8.4.4
      routes:
      - to: default
        via: 172.100.100.3  # 베스천 인스턴스의 내부 IP를 지정한다
      dhcp4: false
---
# 

# 설정 영구 저장 (중요)
# iptables 명령어는 서버를 재시작하면 초기화된다. 이를 방지하기 위해 영구 저장을 사용(모두 Yes)
sudo apt install iptables-persistent
sudo netfilter-persistent save

# ######################################################################################################




# ######################################################################################################
# NFS System 구성
# ======================================================================================================
# Ubuntu에서 저장공간 추가하기 : 새로운 하드디스크 추가한 상태 50Gi
# ------------------------------------------------------------------------------------------------------
# 1. 추가된 저장공간 확인하기
lsblk
---
NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda                         8:0    0   30G  0 disk 
├─sda1                      8:1    0    1M  0 part 
├─sda2                      8:2    0    2G  0 part /boot
└─sda3                      8:3    0   28G  0 part 
  └─ubuntu--vg-ubuntu--lv 252:0    0   28G  0 lvm  /
sdb                         8:16   0   50G  0 disk 
sr0                        11:0    1  3.1G  0 rom
---
# 위 사용예 처럼 새로 추가한 저장장치명은 sdb인 것을 확인할 수 있다.(/dev/sdb)

# 2. 디스크 포맷 : /dev/sdb의 모든 데이터가 삭제
# 1번 (안정성)	ext4	가장 표준적이고 문제가 안생길 때 우선순위도 접근하기 가장 쉽다.
# 2번 (성능)	XFS	데이터 쓰기가 빈번한 DB나 로그 저장용으로 사용할 예정이라면 추천
#        --> sudo apt update && sudo apt install -y xfsprogs
#        --> 사용(포맷) : sudo mkfs.xfs /dev/sdb
# 3번 (기능성)	Btrfs	파일시스템 환경에서 백업(스냅샷) 기능을 자주 쓴다면 추천
sudo mkfs.ext4 /dev/sdb

# 3. 디렉토리 마운트: 물리적 공간과 디렉토리를 연결, 이후 디렉토리명으로 장치 사용
# 1) 마운트 실행
sudo mkdir /mnt/DATA
sudo mount /dev/sdb /mnt/DATA

# 2) 용량 확인 (50G가 있는지 확인)
df -h /mnt/DATA
---
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb         49G   24K   47G   1% /mnt/DATA
---

# 3) 권한 재설정 (마운트를 하면 권한이 바뀔수 있으므로 다시 설정)
sudo chown -R nobody:nogroup /mnt/DATA
sudo chmod -R 777 /mnt/DATA

# 4. 부팅시 자동 마운트 설정
# 1) 디스크의 UUID(고유 식별자) 확인:
sudo blkid /dev/sdb
---
/dev/sdb: UUID="99c7ebbc-7e90-479f-bfc1-15eb076fa662" BLOCK_SIZE="4096" TYPE="ext4"
---

# 2) fstab 파일 수정 : 마지막 줄에 내용 추가
sudo vim /etc/fstab
---
UUID=복사한UUID /mnt/nfs_share ext4 defaults 0 2
---
UUID=c1cd102c-42a6-41f2-9ace-95d949ffac51 /mnt/DATA ext4 defaults 0 2

# 3) 설정 테스트
# ※ 수동으로 마운트 해제 (현재 연결된 상태이므로)
sudo umount /mnt/DATA

# ※ fstab에 내용을 읽어와 다시 마운트 시도
sudo mount -a

# ※ 마운트 결과 확인 (50G 용량과 ext4 타입이 보여야 함)
df -hT /mnt/DATA
---
Filesystem     Type  Size  Used Avail Use% Mounted on
/dev/sdb       ext4   49G   24K   47G   1% /mnt/DATA
---

# ======================================================================================================
# NFS 환경 설정 : 네트워크를
# ------------------------------------------------------------------------------------------------------
# 네트워크 설정 변경: 라우팅 정보 기재
---
network:
  version: 2
  ethernets:
    ens33:
      addresses:
      - 172.100.100.4/24
      nameservers:
        addresses:
        - 8.8.8.8
        search:
        - 8.8.4.4
      routes:
      - to: default
        via: 172.100.100.3  # 베스천 인스턴스의 내부 IP를 지정한다
      dhcp4: false
---


# 패키지 업데이트 및 설치
sudo apt update
sudo apt install -y nfs-kernel-server
# +------------------------------------------------------------------------------------------------------+
# |   데몬 이름       역할                                                                                  |
# +------------------------------------------------------------------------------------------------------+
# |   nfsd          실제 NFS의 메인 데몬으로, 클라이언트의 요청(파일 읽기/쓰기 등) 처리합니다    |
# |   rpcbind       RPC(Remote Procedure Call) 프로그램 번호를 TCP/UDP 포트 번호로 변환해 줍니다    |
# |                 NFS가 RPC 기반이라 이 서비스가 반드시 먼저 떠있어야 합니다.    |
# |   rpc.mountd    클라이언트가 mount 요청을 보내면 /etc/exports 설정에 따라 허용 여부를 결정하고 관리합니다.    |
# |   rpc.statd     파일 잠금(Lock) 상태를 모니터링하여, 서버가 비정상 종료 시 복구되었을 때 복원을 담당합니다.    |
# +------------------------------------------------------------------------------------------------------+

# 공유 디렉토리 생성 및 권한 설정
sudo mkdir -p /mnt/DATA
sudo chown -R nobody:nogroup /mnt/DATA
sudo chmod -R 777 /mnt/DATA

# 1. NFS 공유 설정(Exports)
sudo vim /etc/exports
# 마지막 줄에 아래 내용 추가
---
/mnt/DATA 172.100.100.0/24(rw,sync,no_subtree_check,no_root_squash)
---

# 2. 설정 반영 및 서비스 재시작
# 1) 설정 파일의 내용을 커맨드에 적용
sudo exportfs -ra

# 2) NFS 서버 서비스 재시작
sudo systemctl restart nfs-kernel-server

# 3) 서비스가 잘 돌아가고 있는지 확인 (Active: active (running) 확인)
sudo systemctl status nfs-kernel-server

# 3. 공유 상태 확인
sudo exportfs -v
---
/mnt/DATA       172.100.100.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,no_root_squash,no_all_squash)
---

# 4. 최종 확인 NFS 서버가 아닌 k8s 노드(172.100.100.3,5~9)에서 실행
# 단 NFS 서버를 제외한 모든 생성된 또는 생성할 인스턴스에 NFS 사용을 위한 클라이언트 쪽 패키지를 설치해 줌
sudo apt update
sudo apt install -y nfs-common
showmount -e 172.100.100.4
---
Export list for 172.100.100.4:
/mnt/DATA 172.100.100.0/24
---

# ######################################################################################################




# ######################################################################################################
# MySQL Master 구성
# ======================================================================================================
# 1. Storage Mount 환경 설정 : NFS 참고
# ------------------------------------------------------------------------------------------------------

# ======================================================================================================
# 2. Docker 설치
# ------------------------------------------------------------------------------------------------------
# HTTPS를 사용할 패키지 저장소에 접근하기 위해 패키지를 설치
sudo apt update
# Docker 설치에 필요한 패키지들 설치
sudo apt -y install apt-transport-https ca-certificates gnupg lsb-release
# Docker의 공식 GPG키를 시스템에 추가.
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
# Docker를 repository URL 등록 
sudo echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
# 새로운 저장소가 추가되었으므로 repository update를 통해 패키지 목록 갱신
sudo apt update
# docker, containerd.io 설치.
sudo apt -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 
# docker 버전확인을 통한 설치 여부 확인
docker version
# docker 명령어를 sudo 없이 실행하기 위해 현재 사용자를 docker 그룹에 추가
sudo usermod -a -G docker $USER
# 설정 적용을 위한 재부팅
sudo reboot


# ======================================================================================================
# MySQL 이중화
# MySQL-Master : 온프레미스 서버로 구성되며 도커 컨테이너 사용
# MySQL-Slave : 파드로 구성
# ======================================================================================================
# MySQL Master 설치 및 설정
# ------------------------------------------------------------------------------------------------------
# 1. 볼륨 디렉토리 생성 및 환경 파일 생성
mkdir -p /mnt/DATA/mysql/config 
mkdir -p /mnt/DATA/mysql/data 
mkdir -p /mnt/DATA/mysql/initdb.d 
mkdir -p /mnt/DATA/mysql/logs
# 2. (선택 사항) MySQL 컨테이너 유저가 쓸 수 있도록 권한 부여
# MySQL 공식 이미지의 유저 ID는 보통 999입니다
sudo chown -R 999:999 /mnt/DATA/mysql/data 
sudo chown -R 999:999 /mnt/DATA/mysql/logs
# 3. 환경 설정 파일 생성 : /mnt/DATA/mysql/config/my.cnf
# ==> 파일 참고
# 4. 초기화 파일 생성 : ~/mysql/initdb.d/setup.sql
cd /mnt/DATA/mysql/initdb.d
# 파일 생성 : 권한 문제로 파일이 생성되지 않을 경우 sudo vim setup.sql로 작업
sudo cat <<EOF > setup.sql
<<<<<<< HEAD
CREATE USER 'ian'@'%' IDENTIFIED WITH mysql_native_password BY '***REMOVED***';
GRANT ALL PRIVILEGES ON *.* TO 'ian'@'%' WITH GRANT OPTION;
CREATE USER 'repl_user'@'%' IDENTIFIED WITH mysql_native_password BY '***REMOVED***';
=======
CREATE USER 'ian'@'%' IDENTIFIED WITH mysql_native_password BY '${MYSQL_PASSWORD}';
GRANT ALL PRIVILEGES ON *.* TO 'ian'@'%' WITH GRANT OPTION;
CREATE USER 'repl_user'@'%' IDENTIFIED WITH mysql_native_password BY '${MYSQL_REPL_PASSWORD}';
>>>>>>> origin
GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';
FLUSH PRIVILEGES;
EOF
# compose파일 생성 : ~/mysql/docker-compose.yaml
vim ~/mysql/docker-compose.yaml
# 컨테이너 올리기
cd ~
docker compose up -d
# 외부에서 접속하는 것과 동일한 효과를 얻기 위해 -h 옵션을 사용합니다
docker exec -it mysql-master mysql -u ian -p
<<<<<<< HEAD
mysql -h 172.100.100.5 -u ian -p***REMOVED*** -e "SELECT VERSION();"
=======
mysql -h 172.100.100.5 -u ian -p${MYSQL_PASSWORD} -e "SELECT VERSION();"
>>>>>>> origin
# ======================================================================================================
# 결과가 안나올 경우
# 로그확인 : tail -n 50 ~/mysql/logs/error.log
# 1. 컨테이너 중지 및 볼륨 삭제
cd ~/mysql
docker compose down -v
# 2. 인스턴스의 데이터 폴더 수동 삭제 (디렉토리 재생성 포함)
sudo rm -rf /mnt/DATA/mysql/data/*
# 3. 다시 실행 (이때 setup.sql이 반드시 실행됩니다)
docker compose up -d

# ######################################################################################################




# ######################################################################################################
# 쿠버네티스 기본 구성하기 : k8s-master 구성
# ======================================================================================================

# ======================================================================================================
# 1. Docker 설치 : MySQL Master 구성의 Docker 설치 참고
# ------------------------------------------------------------------------------------------------------

# ======================================================================================================
# 2. 쿠버네티스 설치
# ------------------------------------------------------------------------------------------------------

# ======================================================================================================
# 3. 워커 노드 복제(clone)
# ------------------------------------------------------------------------------------------------------

# ======================================================================================================
# 4. 쿠버네티스 초기화: kubeadm init
# ------------------------------------------------------------------------------------------------------

# ======================================================================================================
# 5. 쿠버네티스 클러스터 구성(연결/sudo kubeadm JOIN ... ) <== 각 노드에서 실행
# ------------------------------------------------------------------------------------------------------

# ======================================================================================================
# 6. 워커노드 구성이 되지 않을 경우 <== 해당 노드에서 실행
# ------------------------------------------------------------------------------------------------------




# ######################################################################################################
# MySQL Slave 설치 및 설정 : NFS pv
# ======================================================================================================
# 1. 슬레이브 접속 시도 (이제 ready for connections 상태이므로 접속할 겁니다)
<<<<<<< HEAD
kubectl exec -it deployment/mysql-slave -- mysql -u ian -p***REMOVED***
=======
kubectl exec -it deployment/mysql-slave -- mysql -u ian -p${MYSQL_PASSWORD}
>>>>>>> origin

# 2. MySQL 안에서 복제 중지 및 재시작
STOP SLAVE;
START SLAVE;

# 3. 상태 확인
SHOW SLAVE STATUS\G




# ======================================================================================================
# StatefulSet 으로 파드 생성 후속 작업
# 1. slave-1 파드 내부의 MySQL 접속
# pv 생성에 필요한 디렉토리를 각 노드에 생성할껀데
# pv에 지정된 디렉토리 모두를 각노드에 생성
sudo mkdir /mnt/mysql-data-0  /mnt/mysql-data-1
sudo chmod -R 777 /mnt/mysql-data-0
sudo chmod -R 777 /mnt/mysql-data-1



<<<<<<< HEAD
kubectl exec -it mysql-slave-1 -- mysql -u root -p***REMOVED***
=======
kubectl exec -it mysql-slave-1 -- mysql -u root -p${MYSQL_ROOT_PASSWORD}
>>>>>>> origin

# 2. MySQL 안에서 아래 쿼리 실행
# super_read_only가 켜져 있어도 root는 설정을 바꿀 수 있습니다.
# Deployment or StatefulSet의 replicas: 1 보다 확장시
SET GLOBAL server_id = 3;

# 3. 변경된 ID를 적용하기 위해 복제 프로세스 재시작
STOP SLAVE;
START SLAVE;

# 4. 복제 상태 확인 (2개 필드가 모두 Yes여야 성공)
SHOW SLAVE STATUS\G

# 그래도 안될 경우
<<<<<<< HEAD
kubectl exec -it mysql-slave-1 -- mysql -u root -p***REMOVED***
=======
kubectl exec -it mysql-slave-1 -- mysql -u root -p${MYSQL_ROOT_PASSWORD}
>>>>>>> origin
-- 1. 복제 스레드 중지
STOP SLAVE;

-- 2. 마스터 주소를 호스트네임 이름에서 실제 IP(172.100.100.21)로 변경
CHANGE MASTER TO 
  MASTER_HOST='172.100.100.21',
  GET_MASTER_PUBLIC_KEY=1;

-- 3. 복제 스레드 시작
START SLAVE;

-- 4. 상태 확인
SHOW SLAVE STATUS\G


# ######################################################################################################




# ######################################################################################################
# nginx 구성
# ======================================================================================================




# ######################################################################################################




# ######################################################################################################
# fastAPI 구성
# ======================================================================================================




# ######################################################################################################
# ######################################################################################################